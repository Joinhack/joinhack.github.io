<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>Joinhack&#39;s Blog</title>
    <link>http://sample.com</link>
    <pubDate>2015-05-22 06:01:24 +0800</pubDate>
    <item>
      <title>三色标记回收</title>
      <link>http://sample.com/垃圾回收/三色标记回收/</link>
      <pubDate>2015-05-15 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;三色标记回收&lt;/h2&gt;

&lt;p&gt;三色标记回收算法中的3个颜色分别是 白、黑、灰.三色标记回收算法大致如下:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将初始化的对象置为白色&lt;/li&gt;
&lt;li&gt;所有根(全局变量或栈上的变量)可及的对象置为灰色&lt;/li&gt;
&lt;li&gt;遍历这些被置位灰色的对象，灰色对象引用到的对象都置为灰色，完成对灰色变量的遍历后，将灰色对象置为黑色&lt;/li&gt;
&lt;li&gt;继续遍历其他被灰色对象&lt;/li&gt;
&lt;li&gt;所有灰色对象遍历完后，就只会剩下黑色的和白色的对象&lt;/li&gt;
&lt;li&gt;所有这些黑色的对象都是根可达的，白色的都是根不可达的，白色对象都删除掉。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上步骤就是三色标记回收的理论了。 非常简单吧， 至少在STW(STOP THE WORLD)的情况下.&lt;/p&gt;

&lt;p&gt;但是在mutator（mutator 与 collector分别是执行应用程序与执行GC）和GC同时工作的时候要满足 &lt;strong&gt;黑色对象只会引用灰色的对象或其他黑色对象。&lt;/strong&gt; 变得复杂起来了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>两色标记回收</title>
      <link>http://sample.com/垃圾回收/两色标记回收/</link>
      <pubDate>2015-05-15 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;两色标记回收&lt;/h2&gt;

&lt;p&gt;两色垃圾回收算法中的2个颜色分别是 白、黑. 算法大致如下:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将初始化的对象置为白色&lt;/li&gt;
&lt;li&gt;所有根(全局变量或栈上的变量)可及的对象置为黑色&lt;/li&gt;
&lt;li&gt;清理所有白色对象&lt;/li&gt;
&lt;li&gt;将幸存的黑色对象全部置为白色&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这应该是最简单的mark-sweep算法. Lua5.0 就是采用的这种算法。 这种算法的缺点一目了然。 不是增量的GC算法。因此GC过程中mutator肯定是被paused的。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>redis的hash表</title>
      <link>http://sample.com/redis/redis的hash表/</link>
      <pubDate>2015-05-10 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;redis的hash表&lt;/h2&gt;

&lt;p&gt;首先还是先说说hash表是什么？ 很多语言有不同的定义 java中的HashMap HashTable， golang中的map都是hash表的实现。大致原理如下：&lt;/p&gt;

&lt;p&gt;hash表添加KEY-VALUE&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将KEY计算hash，将KEY的hash值与slots数求莫后找到对应slot. 如果slot有值循环整个slot对应的KEY-VALUE 如果slot中的KEY与加入的KEY相等 就覆盖其VALUE， 如果不等就追加到slot后面。&lt;/li&gt;
&lt;li&gt;达到占用slots的阀值expand slots, 遍历已有的数据重新加入扩展后的slots中(rehashing)。&lt;/li&gt;
&lt;li&gt;未达到阀值，完成hash插入操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;hash表删除KEY&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将KEY计算hash，将KEY的hash值与slots数求莫后 找到对应的slot。&lt;/li&gt;
&lt;li&gt;遍历整个slot依次对比KEY， 找到与KEY相等的KEY-VALUE将其移除。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;hash表查找KEY的对象&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将KEY计算hash，将KEY的hash值与slots数求莫后 找到对应的slot。&lt;/li&gt;
&lt;li&gt;遍历整个slot依次对比KEY， 找到与KEY相等的KEY-VALUE将VALUE返回。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面就是hash表的工作原理。总体来说hash表的查询都是O(1) 删除也算是O(1), 从整体上来看也是一个O(1)操作， 这里不考虑hash碰撞的情况（如果碰撞最坏情况就变成O(N)）。 但是事实上如果插入非常频繁，从步骤就能看出, 就会经常expand， 这样插入肯定不会是O(1)的。&lt;/p&gt;

&lt;p&gt;redis的提供的数据结构之一也是hash表，但是redis的hash表明做了写优化， 就算是频繁插入也能达到O(1). 的时间复杂度。下面就是redis的hash表结构。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//数据结果是从dict.h拷贝来的。
typedef struct dictht {
    dictEntry **table;  //这里就是上面提到的slots 一般是一个链表
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;

typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2]; //2个dictht 这个就是用于写优化
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
    int iterators; /* number of iterators currently running */
} dict;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;redis 写优化结构的hash表 与普通hash表最主要的区别就是rehashing的时候移动动完所有的数据，而是将rehashing过程平摊到每次读写过程中去。&lt;/p&gt;

&lt;p&gt;redis hash表添加KEY-VALUE (rehashing 过程中)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将老表(dict中ht[0])中的一个KEY-VALUE移动到新表(dict中ht[1])中去。&lt;/li&gt;
&lt;li&gt;新表作中(dict中ht[0])slots作为添加数据的目标， 然后将KEY-VALUE添加入hash表。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;hash表删除KEY (rehashing 过程中)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果将老表(dict中ht[0])中的一个KEY-VALUE移动到新表(dict中ht[1])中去。&lt;/li&gt;
&lt;li&gt;同时在将老表与新表中的依次找KEY，如果在老表中找到KEY就删除，无需再删除新表。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;hash表删除KEY (rehashing 过程中)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将老表(dict中ht[0])中的一个KEY-VALUE移动到新表(dict中ht[1])中去。&lt;/li&gt;
&lt;li&gt;同时在将老表与新表中的依次找KEY，如果在老表中找到KEY就返回，无需再找新表。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
  </channel>
</rss>